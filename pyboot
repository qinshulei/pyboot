#!/usr/bin/env python
#
# pyboot: automatically load/boot kernel + DTB + initrd
#
# Automatically load and boot kernel image (and optionally load DTB
# and initrd) on <board> using netboot (DHCP + TFTP).  Images are
# copied to a temporary, TFTP-accessible location (unless already
# under TFTP root dir) so they can be loaded by <board> via TFTP.
#
# Serial console and hardreset/power-down of <board> is handled
# through conmux.  Conmux provides the serial console, and also allows
# special escape that can run arbitrary commands and are useful for
# hardreset and power-off of target board.
#
# Reads config file from /etc/pyboot.conf, $PWD/.pyboot and ~/.pyboot
#
# Authors:
#   Olof Johansson <olof@lixom.net>
#   Kevin Hilman <khilman@kernel.org>
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
# TODO:
# - generalize bootargs: set by inserting into DTB, not only u-boot env
#   - needs to handle current post-dhcp init (via netargs)
# - instrument kernel backtraces for easy logging/coloring
# - add 'console_host' option in config file for conmux
# - support arch, mach, lab-name, etc. from ~/.pyboot
# - detect missing qemu binaries more gracefully
#
from __future__ import print_function
import os
import sys
import time
import stat
import re
import pexpect
import getopt
import tempfile
import shutil
import subprocess
try:
    import configparser
except:
    import ConfigParser as configparser
import json
import struct
import fcntl
import operator

def usage():
    name = os.path.basename(sys.argv[0])
    print()
    print(name, "[options] <board> [<kernel>[:addr]] [<dtb>[:addr]] [<initrd>[:addr]")
    print("  -h: this help message")
    print("  -d: enable debug mode")
    print("  -v: display verbose interaction with target")
    print("  -i: after kernel boots, enter interactive mode with serial console")
    print("  -u <addr>: create uImage from zImage with <addr> as load address")
    print("             (useful when u-boot is missing bootz support)")
    print("  -c <cmdline>: append on to kernel commandline")
    print("  -t: run tests defined in config file")
    print()

def path_addr_split(path):
    """Split the argument (of the form path[:addr] into (path, addr)"""
    addr = None
    if path == '-':
        return (None, None)
    if path.find(':') != -1:
        (path, addr) = path.split(':')
    if not os.path.exists(path):
        print("ERROR: file", path, "does not exist.")
        sys.exit(1)
    return (path, addr)

def progress(str, log=False):
    global start_time, c
    if dry_run:
        return

    t = time.time() - start_time
    min = t / 60
    sec = t % 60
    timestamp = '[%02d:%02d]' %(min, sec)

    if log and c.logfile:
        c.logfile.flush()
        c.logfile.write("\n# PYBOOT: %s\n" %str)

    if verbose:
        # target console output is already verbose enough, don't add to it
        return

    if not quiet:
        print('%s %s' %(timestamp, str))

def create_uimage(kimg, addr_str):
    """ Create uImage from kernel Image with @addr ad load address. """
    # Check if 'addr' is hex.  If not, it might be path to System.map,
    # where look for _text symbol to determine load address
    try:
        addr = int(addr_str, 16)
        entry = addr
    except ValueError:
        if os.path.exists(addr_str):
            system_map = addr_str
            virt_text = subprocess.check_output('grep " _text" %s' %system_map, shell=True).split()[0]
            text_offset = '0x' + virt_text.replace('c', '0')
            addr = int(text_offset, 16)
            entry = addr
            if not quiet:
                print("uImage: determined load address (0x%08x) from %s." %(addr, system_map))
        elif addr_str == "xip":
            addr = int(loadaddr, 16)
            entry = addr + 64
            if not quiet:
                print("uImage: XIP mode: Setting uImage load addr to TFTP load addr 0x%08x (and entry point +64b)" %(addr))
        else:
            addr = uimage_addr_default
            entry = addr
            print("WARNING: uImage: Unable to determine load address from %s. Using default 0x%08x" %(addr_str, addr))

    fd, uimg = tempfile.mkstemp(prefix="uImage-")
    temp_files.append(uimg)
    cmd = 'mkimage -A %s -O linux -T kernel -C none -a 0x%x -e 0x%x -n "Linux" -d %s %s > /dev/null' %(arch, addr, entry, kimg, uimg)
    subprocess.call(cmd, shell=True)
    os.chmod(uimg, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
    if not os.path.exists(uimg):
        raise Exception('Unable to create uImage.')
    else:
        progress("Convered zImage to uImage (arch = %s, load address = 0x%08x)" %(arch, addr))

    return uimg

def tftp_setup():
    """ Create temp TFTP location. """
    global tftpdir, tftprel

    tftptmp = os.path.join(tftproot, 'tmp')
    if not os.path.exists(tftptmp):
        os.mkdir(tftptmp)
    tftpdir = tempfile.mkdtemp(prefix='%s-' %board, dir=tftptmp)
    os.chmod(tftpdir, stat.S_IRWXU | stat.S_IXGRP | stat.S_IXOTH)
    tftprel = os.path.relpath(tftpdir, tftproot)

def tftp_relpath(path):
    """Copy file into tftproot for access via TFTP and return path.
    If path is already under tftproot, do not copy, just return
    relative path.
    """
    global tftpdir, tftprel

    if path.startswith(tftproot):
        # already in TFTP root, no need to copy, just drop TFTP root prefix
        path = path[len(tftproot)+1:]
    else:
        shutil.copy(path, tftpdir)
        path = os.path.join(tftprel, os.path.basename(path))

    return path

def tftp_cleanup():
    global tftpdir

    if tftpdir:
        shutil.rmtree(tftpdir)
        tftpdir = None

def time_start(key):
    global timings

    if key not in timings:
        timings[key] = [0, 0, 0]

    timings[key][0] = time.time()

def time_stop(key):
    timings[key][1] = time.time()
    diff = timings[key][1] - timings[key][0]
    if diff < 0:
        diff = 0
    timings[key][2] = diff

def time_diff(key):
    return timings[key][2]

def do_report(retval=0, result=None):
    global start_time, c, boot_meta

    time_stop('total')
    if not result:
        if retval:
            result = 'FAIL'
        else:
            result = 'PASS'

    # sort by total time
    timings_sorted = sorted(list(timings.items()), key=lambda x: x[1][2], reverse=True)

    report = "#\n# PYBOOT: cmdline: pyboot " + " ".join(sys.argv[1:]) + "\n"
    if 'total' in timings:
        report += "# PYBOOT: Time: %.2f" %time_diff('total')
    report += " ("
    for i, t in enumerate(timings_sorted[1:]):
        report += "%s: %.2f" %(t[0], t[1][2])
        if i < len(timings_sorted) - 2:
            report += ", "
    report += ")\n"
    if warnings:
        report += "# PYBOOT: Warnings: %d\n" %warnings
    report += "# PYBOOT: Result: %s\n" %result
    if not quiet:
        print(report)

    if c and c.logfile:
        c.logfile.flush()
        c.logfile.write(report)

    boot_time = 0
    if 'kernel' in timings:
        boot_time = round(time_diff('kernel'), 2)
    boot_meta["boot_time"] = round(boot_time, 2)
    boot_meta["boot_result"] = result
    boot_meta["boot_warnings"] = warnings
    boot_meta["boot_log"] = logfile

    # Create JSON format boot metadata
    json_file, ext = os.path.splitext(logfile)
    json_file += ".json"
    if os.path.exists(json_file):
        boot_json_f = open(json_file, 'r')
        prev_boot_meta = json.load(boot_json_f)
        boot_retries = prev_boot_meta.get("boot_retries", 0)
        boot_json_f.close()
        boot_meta["boot_retries"] = boot_retries + 1

    json_base = os.path.dirname(json_file)
    if json_base and not os.path.exists(json_base):
        os.mkdir(json_base)
    boot_json_f = open(json_file, 'w')
    json.dump(boot_meta, boot_json_f, indent=4, sort_keys=True)
    boot_json_f.close()

    sys.exit(retval)

class dummy_expect:
    """ Dummy expect for debug without using real console. """
    class dummy_match:
        def group(self, i):
            return i
    def __init__(self):
        self.match = self.dummy_match()
        self.logfile = None
    def sendline(self, str):
        print(str)
    def expect(self, exp=None, timeout=0):
        return 0
    def before(self):
        return 'BEFORE'

def connect_console():
    """ Spawn and connect to serial console (via conmux). """
    global c, verbose, exp_logfile
    global kimage, dtb, initrd

    if dry_run:
        c = dummy_expect()
        return

    if sys.version_info.major == 3:
        kwargs = dict(encoding='utf-8', codec_errors='ignore')
    else:
        kwargs = {}
    if qemu:
        boot_meta["qemu_version"] = subprocess.check_output("%s -version" % qemu, shell=True)
        qemu_cmd = "%s -nographic %s -kernel %s" %(qemu, qemu_args, kimage)
        if dtb:
            qemu_cmd += " -dtb %s" %dtb
        if initrd:
            qemu_cmd += " -initrd %s" %initrd
        if bootargs:
            qemu_cmd += " -append \"%s\"" %bootargs
        boot_meta["qemu_command"] = qemu_cmd
        c = pexpect.spawn(qemu_cmd, timeout=30)
    else:
        conmux_board = board
        if conmux_host:
            conmux_board = "%s/%s" %(conmux_host, board)
        c = pexpect.spawn("conmux-console %s" %(conmux_board), timeout=30, **kwargs)
    try:
        fd, exp_logfile = tempfile.mkstemp(prefix="conmux-log-")
        temp_files.append(exp_logfile)
        c.logfile = open(exp_logfile, "w")

    except IOError:
        print('WARNING: Unable to open %s.  Enabling verbose mode.' %logfile)
        verbose = True

    #
    # For interactive use (in addition to logging, connect stdout to
    # logfile_read (logfile_read is used so characters are not echo'd
    # twice)
    #
    if verbose:
        c.logfile_read = sys.stdout

    if qemu:
        # QEMU goes directly to booting the kernel
        progress("qemu: connected using: %s" %qemu_cmd, log=True)
        return;

    i = c.expect(["Connected to",
                  pexpect.TIMEOUT, pexpect.EOF])
    if i == 0:
        # connected normally
        pass
    else:
        raise Exception('ERROR: Unable to connect to console.  Giving up.', 'OFFLINE')

    c.sendline('')
    progress('console: connected.', log=True)

def chunkstring(line, n):
    return [line[i:i+n] for i in range(0, len(line), n)]

def sendline(str):
    global c, uart_fifo_hack

    if not c:
        return

    if uart_fifo_hack:
        for chunk in chunkstring(str, uart_fifo_hack):
            c.send(chunk)
        c.sendline('')
    else:
        c.sendline(str)

def command(str, exp=None, timeout=300):
    global prompt

    if debug:
        progress('cmd: %s' % str)
    sendline(str)
    i = c.expect([exp or prompt,
                  pexpect.EOF,
                  pexpect.TIMEOUT], timeout=timeout)
    if i == 0:
        # double-check if this prompt is the result of the command we just sent.  If not,
        # it probably means we're missing a c.expect() someplace
        if debug and (not str in c.before):
            progress('WARN: command(%s): str was not in c.before="%s"' % (str, c.before))
        pass
    elif i == 1:
        raise Exception("ERROR: console: unexpectedly disconnected.")
    else:
        raise Exception("ERROR: Timeout waiting for command: %s." %str)

def boot_to_uboot():
    global prompt, post_reset_ctrl, bootloader_custom
    hardreset = True

    breakin = False
    while not breakin:
        if hardreset:
            c.sendline('~$hardreset')

        # Send "post_reset_ctrl" character as a control character right after reset
        if post_reset_ctrl:
            # on chromebook, must wait until board is powered up, which may take
            # some time due to locking/delays in talking with PDU
            # FIXME: need a way to detect when power cycle actually happends
            time.sleep(10)
            progress("console: send post_reset_ctrl: %s" %post_reset_ctrl)
            for ch in post_reset_ctrl:
                c.sendcontrol(ch)

        # Break into u-boot
        i = c.expect(['stop autoboot',
                      'BOOT0 is starting',
                      'fastboot: processing commands',
                      'Nokia OMAP Loader',
                      'ASSERT FAILED at \(platform/msm_shared/usb30_dwc.c',
                      'Starting depthcharge on',
                      'BOLT v([\d\.]+)\s',
                      'CFE version ([\d\.]+)\s',
                      'Please RESET the board',
                      pexpect.TIMEOUT], timeout = 45)
        if i == 0:
            breakin = True
        elif i == 1:
            if "sun4i-a10-cubieboard" in dtb_orig:
                progress('u-boot: HACK: Cubie: old, on-chip bootloader detected.  Resetting again.')
                hardreset = True
            else:
                progress('u-boot: HACK: Not a sun4i-a10-cubieboard.  Ignoring: %s' %dtb_orig)
                hardreset = False
            continue
        elif i == 2:
            progress('u-boot: fastboot mode detected.')
            return False
        elif i == 3:
            progress('u-boot: Nokia OMAP Loader (NOLO) detected.')
            return False
        elif i == 4:
            progress('u-boot: HACK: IFC6540: USB assert detected.  Resetting again.')
            continue
        elif i == 5:
            progress("u-boot: coreboot/depthcharge detected. Entering netboot mode.")
            c.sendcontrol('N')  # Send Ctrl-N to enter netboot mode
            return False
        elif i == 6 or i == 7:
            progress("console: bootloader detected: %s" % c.match.group(0))
            bootloader_custom = True
            return False
        elif i == 8:
            progress("u-boot: failure to boot.", "OFFLINE")
        else:
            raise Exception('ERROR: Could not break into u-boot.', 'OFFLINE')

    c.send('\r')
    c.send('\r')  # ugh, some board need two keys pressed (odroid-c2)
    progress('u-boot: taking control.', log=True)

    # Find u-boot prompt
    try:
        c.expect('[-\w ]*[>#\$]')
    except pexpect.TIMEOUT:
        raise Exception('ERROR: Could not find u-boot prompt.', 'OFFLINE')

    prompt = c.match.group(0)
    if prompt.endswith('$'):
        prompt = prompt[:-1] + "\$"

    # due to the extra <enter> press above, need to flush the 2nd prompt from
    # the input buffer.  Note that 2nd prompt wont be there when 2 keypresses
    # are actually needed, so timeout quickly)
    c.expect([prompt, pexpect.TIMEOUT], timeout=0.2)
    return True

def init_uboot_env():
    """ Initialize default u-boot env, including values from config file."""
    global prompt, custom_boot

    # Send this command one char at time
    if uboot_early:
        for ch in uboot_early:
            c.send(ch)
        c.send("\n")
        c.expect(prompt)

    command('version')

    # environment values from config file
    if uboot_env:
        uboot_vars = uboot_env.split('\n')
        uboot_vars = [_f for _f in uboot_vars if _f] # remove empty items, blank lines...
        for var in uboot_vars:
            (key, val) = var.split('=', 1)
            command('setenv %s %s' %(key, val))

            # If 'bootcmd' is set, assume we shoudl use this instead of the standard
            # netboot method
            if key == "bootcmd":
                custom_boot = True

        # if bootargs is set outside of uboot_env, it overrides this one
        if bootargs:
            command('setenv bootargs %s' %bootargs)

    command('if test -n ${initenv}; then run initenv; fi')
    command('if test -n ${preboot}; then run preboot; fi')

def init_net():
    global prompt
    retries = 3

    command('setenv autoload no')
    command('setenv autoboot no')
    while retries and dhcp:
        sendline("dhcp")
        i = c.expect(["DHCP client bound",
                      "Unknown command",
                      "Retry count exceeded",
                      "No link",
                      pexpect.TIMEOUT],
                     timeout = 30)
        if i == 0:
            progress('u-boot: got DHCP address.')
            c.expect(prompt)
            break;
        elif i == 1:
            raise Exception('u-boot: does not support DHCP.  Giving up.', "OFFLINE")
        else:
            retries = retries - 1
            if retries:
                progress('u-boot: DHCP timeout. Trying again (retries=%d)' \
                             %retries, log=True)
            else:
                raise Exception('u-boot: ERROR: timeout getting DHCP address.', "OFFLINE")

    if serverip:
        command('setenv serverip %s' %serverip)

    command("if test -n ${netargs}; then run netargs; fi")

def fastboot_image(kernel, dtb, initrd):
    progress('u-boot: entering fastboot mode.', log=True)
    command('printenv bootargs')
    c.sendline(fastboot_cmd)

    # The rest of the fastboot magic here is hidden by conmux
    progress('fastboot: loading %s, %s, %s' % (kernel, dtb, initrd), log=True)
    cmd = "~$fastboot"
    if serverip:
        cmd += " -t %s" %serverip
    cmd += " %s %s %s" % (kernel, dtb, initrd)
    c.sendline(cmd)

def load_image(file, addr):
    global prompt
    retries = 3
    tftp_cmd = 'tftp'
    if serverip:
        file = "%s:%s" %(serverip, file)

    progress('u-boot: TFTP %s to %s' %(file, addr))
    while retries:
        sendline('%s %s %s' %(tftp_cmd, addr, file))
        retries = retries - 1
        i = c.expect(['Bytes transferred',
                      'TFTP error',
                      'Unknown command',
                      'No link',
                      'Retry count exceeded',
                      pexpect.TIMEOUT],
                     timeout=180)
        if (i == 0):
            j = c.expect([prompt, pexpect.TIMEOUT])
            if j != 0:
                raise Exception("u-boot: ERROR: No prompt after TFTP transfer", "OFFLINE")
            break
        elif (i == 1):
            raise Exception('ERROR: TFTP error.', "OFFLINE")
        elif (i == 2):
            if tftp_cmd == "tftp":
                progress("u-boot: tftp command not present, trying tftpboot")
                tftp_cmd = "tftpboot"
                c.expect(prompt)
            else:
                raise Exception("ERROR: u-boot doesn't support TFTP", "OFFLINE")
        elif (i == 3):
            raise Exception("ERROR: u-boot: No network connection", "OFFLINE")
        else:
            if retries:
                progress('u-boot: timeout loading %s, Trying again.' %file, log=True)
                c.send('\003')  # Ctrl-C: abort current tftp
                j = c.expect([prompt, pexpect.TIMEOUT])
                if j != 0:
                    raise Exception("u-boot: ERROR: No prompt after interrupting TFTP.", "OFFLINE")
            else:
                raise Exception('ERROR: Timeout loading %s.  Giving up.' %file, "OFFLINE")

def boot_kernel():
    global prompt, initrd_addr

    boot_cmd='bootm'
    if os.path.basename(kimage)[0] == 'z':
        boot_cmd='bootz'
    if os.path.basename(kimage).startswith("Image"):
        boot_cmd='booti'

    if cmdline_append:
        command('setenv bootargs ${bootargs} %s' %cmdline_append)

    command('printenv bootargs')

    # Boot the kernel
    sendline('%s %s %s %s' %(boot_cmd, loadaddr, initrd_addr, dtb_addr))
    progress("u-boot: jumping to kernel image", log=True)

    # U-boot should tell us quickly that it's starting the kernel
    i = c.expect(['Starting kernel',
                  'Unknown command',
                  'Wrong Image Type for bootm',
                  'Bad Linux ARM zImage magic',
                  pexpect.TIMEOUT],
                 timeout = 30)  # allow time for checksumming large ramdisk, etc.
    if i == 0:
        # Kernel started normally
        pass
    elif i == 1:
        raise Exception('u-boot: ERROR: does not support command: %s' %boot_cmd)
    elif i == 2:
        raise Exception('u-boot: ERROR: missing (or overwritten) uImage header')
    elif i == 3:
        raise Exception('u-boot: ERROR: Bad Linux ARM zImage magic.' )
    elif i == 4:
        raise Exception('u-boot: ERROR: Kernel did not start.')

    progress('u-boot: started kernel.')

def wait_for_kernel():
    global warnings

    i = c.expect(['Booting Linux',
                  'Linux version',
                  pexpect.TIMEOUT, pexpect.EOF], timeout = 120)
    if i == 0 or i == 1:
        # normal booting
        pass
    if i == 2:
        raise Exception('kernel: ERROR: did not start booting.')
    if i == 3:
        raise Exception('console: error connecting with console/qemu.', 'OFFLINE')

    progress('kernel: started booting.')

    # Look for end of kernel boot, or various failures
    done = False
    while not done:
        pl = ['Freeing unused kernel memory',
              'Freeing init memory',
              'PM: restore of devices complete',  # detect resore of hibernation image
              'Unable to handle kernel (.*)\r\n',
              'Kernel panic',
              'VFS: Unable to mount root fs',
              '-+\[ cut here \]-+\s+(.*\s+-+\[ end trace (\w*) \]-+)',
              '(Unhandled fault.*)\r\n',
              pexpect.TIMEOUT]
        i = c.expect(pl, timeout=90)
        if i == 0 or i == 1 or i == 2:
            # Kernel booted normally
            done = True
        elif i == 3:
            msg = c.match.group(0)
            raise Exception("kernel: %s" %msg)
        elif i == 6:
            warnings += 1
            progress("kernel: boot warning %d:" % warnings)
            if not quiet:
                print(c.match.group(1))
            continue
        elif i == 7:
            warnings += 1
            msg = c.match.group(0)
            progress("kernel: %s" %msg, log=True)
            continue
        elif i == 8:
            raise Exception("kernel: ERROR: Timeout waiting for kernel to finish booting.")
        else:
            raise Exception('kernel: ERROR: failed to boot: %s' %pl[i])

    progress('kernel: finished booting, starting userspace.', log=True)

def root_shell():
    """ Wait for linux root shell. """
    global prompt, warnings

    # Wait for linux root shell
    prompt = "# "
    pl = [prompt,
          "press Enter to activate",  # busybox
          pexpect.TIMEOUT,
          "Kernel panic",
          "(Unhandled fault.*)\r\n",
          'Unable to handle kernel (.*)\r\n',
          '(initramfs)'
    ]
    done = False
    timeout = 120
    if qemu:
        timeout = 500
    while not done:
        i = c.expect(pl, timeout=timeout)
        if i == 0 or i == 6:
            prompt = c.match.group(0)
            done = True
        elif i == 1:
            command('\n')
            done = True
        elif i == 2:
            raise Exception('userspace: ERROR: Timeout waiting for root shell')
        elif i == 4:
            warnings += 1
            msg = c.match.group(0)
            progress('kernel: %s' %msg, log=True)
        else:
            raise Exception('userspace: failed to find root shell: %s' %pl[i])

    progress("userspace: at root shell", log=True)

def userspace_info():
    global prompt, kernelversion

    command('cat /proc/cmdline')
    progress('userspace: Kernel command line: %s' %c.before.split('\n')[-2])

    command('uname -r')

    kernelversion = c.before.split('\n')[-2]
    progress('userspace: found kernel version: %s' % kernelversion)

    command('cat /proc/cpuinfo')
    for line in c.before.split('\n'):
        match = re.match('Hardware\s+:\s+(.+)\r', line)
        if match:
            progress('userspace: Hardware: %s' %match.group(1))

    if modules:
        command('lsmod')

def check_errors_warnings():
    # FIXME: these commands are sometimes causing problems when interacting with late output
    #        kernel messgages (like USB devices appearing on mirabox.)  To prevent
    #        strange interactions, turn off kernel message output to console.
    command('dmesg -n 1')  # prevent kernel message output from interfering with this
    command('dmesg -n 1')  # prevent kernel message output from interfering with this
    # "dmesg -l" requires "real" dmesg, not busybox dmesg
    command('DMESG=$(readlink -f /bin/dmesg)')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l warn | awk \'{ print "[WARN] " $0 }\'')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l err | awk \'{ print "[ERR] " $0 }\'')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l alert | awk \'{ print "[ERR] " $0 }\'')
    # or, on busybox, just check for kern.err, kern.warn in /var/log/messages
    command('[[ -e /var/log/messages ]] && grep kern.warn /var/log/messages | awk \'{ print "[WARN] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep user.warn /var/log/messages | awk \'{ print "[WARN] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep kern.err /var/log/messages | awk \'{ print "[ERR] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep user.err /var/log/messages | awk \'{ print "[ERR] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep kern.alert /var/log/messages | awk \'{ print "[ERR] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep user.alert /var/log/messages | awk \'{ print "[ERR] " $0 }\'')
    command('sleep 0.2')

def run_test(test, cmd):
    timeout = 1200

    progress('test: %s: %s' %(test, cmd), log=True)
    command(cmd, timeout=timeout)
    command('echo $?')
    retval = int(c.before.split('\n')[-2])
    if retval == 0:
        pass_fail = 'PASS'
    else:
        pass_fail = 'FAIL'

    progress("test: %s: returned %d: %s"  %(test, retval, pass_fail), log=True)

def do_tests():
    # Board-specific tests
    for o in config.options(section):
        if o.startswith('test_'):
            test = o[5:] # drop 'test_' prefix from test name
            cmd = config.get(section, o)
            run_test(test, cmd)

    # Tests defined in [test] section
    if not config.has_section('test'):
        return

    tests = config.options('test')
    for test in tests:
        # ignore options from DEFAULTS section
        if test in config.defaults():
            continue
        cmd = config.get('test', test)
        run_test(test, cmd)

def poweroff():
    global c
    if c:
        c.sendline('~$off')

def dtb_insert_initrd(dtb, initrd_addr):
    """ Insert initrd start/end addresses into DTB.

    NOTE: we could use fdtput for this but the original DTB needs to have
    enough padding in it for the new commandline, which is not guaranteed.
    """
    global initrd_cmdline

    # de-compile DTB into temp DTS
    fd, tmp_dts = tempfile.mkstemp(suffix=".dts")
    temp_files.append(tmp_dts)
    os.close(fd)
    cmd = "dtc -q -I dtb -O dts -o %s %s > /dev/null 2>&1" %(tmp_dts, dtb)
    subprocess.call(cmd, shell=True)

    initrd_start = int(initrd_addr, 16)
    initrd_end = initrd_start + initrd_size_z
    chosen_frag = "/ { chosen { linux,initrd-start = <0x%08x>; linux,initrd-end = <0x%08x>; }; };\n" %(initrd_start, initrd_end)
    fp = open(tmp_dts, 'a')
    fp.write(chosen_frag)
    fp.close()
    initrd_cmdline = True

    # Re-compile DTS into new DTB
    fd, dtb_modified = tempfile.mkstemp(suffix=".dtb")
    temp_files.append(dtb_modified)
    os.close(fd)
    cmd = "dtc -I dts -O dtb -o %s %s > /dev/null 2>&1" %(dtb_modified, tmp_dts)
    subprocess.call(cmd, shell=True)
    os.unlink(tmp_dts)
    os.chmod(dtb_modified, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    if not quiet:
        print("DTB: modified for initrd: %s" %dtb_modified)
    return dtb_modified

def dtb_insert_cmdline(dtb, cmdline):
    global bootargs

    # de-compile DTB into temp DTS
    fd, tmp_dts = tempfile.mkstemp(suffix=".dts")
    temp_files.append(tmp_dts)
    os.close(fd)
    cmd = "dtc -q -I dtb -O dts -o %s %s > /dev/null 2>&1" %(tmp_dts, dtb)
    subprocess.call(cmd, shell=True)

    chosen_frag = '/ { chosen { bootargs = "%s"; }; };\n' %bootargs
    fp = open(tmp_dts, 'a')
    fp.write(chosen_frag)
    fp.close()

    # Re-compile DTS into new DTB
    fd, dtb_modified = tempfile.mkstemp(suffix=".dtb")
    temp_files.append(dtb_modified)
    os.close(fd)
    cmd = "dtc -I dts -O dtb -o %s %s > /dev/null 2>&1" %(dtb_modified, tmp_dts)
    subprocess.call(cmd, shell=True)
    os.unlink(tmp_dts)
    os.chmod(dtb_modified, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    if not quiet:
        print("DTB: modified with bootargs: %s." %(bootargs,))
    return dtb_modified


def initrd_add_uboot_header(initrd):
    """Add u-boot initrd header so it can be booted using u-boot bootm/bootz."""
    basename = os.path.basename(initrd)
    fd, initrd_uboot_tmp = tempfile.mkstemp(prefix=basename, suffix=".uboot")
    temp_files.append(initrd_uboot_tmp)
    os.close(fd)
    cmd = "mkimage -A %s -O linux -T ramdisk -C none -a 0 -e 0 -n %s -d %s %s > /dev/null" %(arch, basename, initrd, initrd_uboot_tmp)
    subprocess.call(cmd, shell=True)
    if os.path.exists(initrd_uboot_tmp):
        if not quiet:
            print(("initrd: Added u-boot header.  Modified initrd: %s" %initrd_uboot_tmp))
        os.chmod(initrd_uboot_tmp, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
        initrd_size_z = os.path.getsize(initrd_uboot_tmp)
        return initrd_uboot_tmp
    else:
        raise Exception("Unable to add u-boot header to initrd %s" %initrd)

def initrd_insert_modules(initrd, modules):
    initrd_tmpdir = tempfile.mkdtemp(prefix="initrd-")
    temp_files.append(initrd_tmpdir)
    fd, initrd_new = tempfile.mkstemp(prefix="initrd-", suffix=".cpio")
    temp_files.append(initrd_new)

    # extract ramdisk into tmp dir
    if initrd.endswith(".cpio"):
        cat_cmd = "cat"
    elif initrd.endswith(".cpio.gz"):
        cat_cmd = "zcat"
    else:
        return None

    cmd = "cd %s && %s %s | fakeroot cpio --extract --quiet" %(initrd_tmpdir, cat_cmd, initrd)
    subprocess.call(cmd, shell=True)

    # unpack modules into tmp dir
    cmd = "tar -C %s -xaf %s" %(initrd_tmpdir, modules)
    subprocess.call(cmd, shell=True)

    # (re)create ramdisk
    cmd = "cd %s && find . | fakeroot cpio --create --quiet --format='newc' > %s" %(initrd_tmpdir, initrd_new)
    subprocess.call(cmd, shell=True)
    subprocess.call("gzip %s" %initrd_new, shell=True)
    initrd_new += ".gz"
    os.chmod(initrd_new, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    if debug:
        print("initrd: Inserted modules (%s) into new ramdisk: %s" %(modules, initrd_new))
    temp_files.append(initrd_new)

    return initrd_new

def zimage_is_big_endian(kimage):
    """Check zImage big-endian magic number"""
    magic_offset = 0x30
    setend_be = 0xf1010200
    setend_be_thumb = 0xb658

    fp = open(kimage, "rb")
    fp.seek(magic_offset)
    val = struct.unpack("=L", fp.read(4))[0]
    fp.seek(magic_offset)
    val16 = struct.unpack("<H", fp.read(2))[0]
    fp.close()
    if (val == 0x01020304) or (val == setend_be):
        return True
    return False

def zimage_hack_endian(kimage):
    zimage_magic_offset = 0x24
    zimage_magic = 0x016f2818
    magic_hack = struct.pack("<L", zimage_magic)  # ensure LE

    fd, zimage_hack = tempfile.mkstemp(prefix="zImage-hack-")
    temp_files.append(zimage_hack)
    os.close(fd)
    shutil.copyfile(kimage, zimage_hack)

    fp = open(zimage_hack, 'rb+')
    fp.seek(zimage_magic_offset)
    fp.write(magic_hack)
    fp.close()
    print("zImage: HACK: forcing little-endian magic number in %s" %zimage_hack)
    return zimage_hack

verbose = False
interact = False
uimage_addr = 0
uimage_addr_default = 0x00008000
convert_uimage = False
shutdown = False  # shutdown/halt and poweroff board when done
cmdline_append = ""
debug = False
dry_run = False
quiet = False
prompt = ''
logfile = None
logfile_append = False
exp_logfile = None
run_tests = False
check_warnings = False
dhcp = True
dtb_append = False
modules = None
build_json_file = None
temp_files = []
lab_name = None
board_name = None
mach = None
uart_fifo_hack = None
c = None

try:
    opts, args = getopt.getopt(sys.argv[1:], "Aab:c:dhil:L:m:M:n:qstu:vwy")

except getopt.GetoptError as err:
    print(str(err)) # will print something like "option -a not recognized"
    sys.exit(2)
for o, a in opts:
    if o == "-A":
        logfile_append = True
    elif o == "-a":
        dtb_append = True
    elif o == "-b":
        build_json_file = a
    elif o == "-c":
        cmdline_append = a
    elif o == "-d":
        debug = True
    elif o == "-y":
        dry_run = True
    elif o == "-h":
        usage()
        sys.exit(0)
    elif o == "-i":
        interact = True
    elif o == "-k":
        locking = False
    elif o == "-l":
        logfile = a
    elif o == "-L":
        lab_name = a
    elif o == "-m":
        modules = a
    elif o == "-M":
        mach = a
    elif o == "-n":
        board_name = a
    elif o == "-s":
        shutdown = True
    elif o == "-q":
        quiet = True
    elif o == "-t":
        run_tests = True
    elif o == "-u":
        convert_uimage = True
        uimage_addr = a
    elif o == "-v":
        verbose = True
    elif o == "-w":
        check_warnings = True
    else:
        assert False, "unhandled option %s" %o

if len(args) < 1:
    usage()
    sys.exit(1)

board = args[0]  # conmux console name
if not board_name:
    board_name = board # used for boot JSON board name
tftproot = '/tftpboot'
tftpdir = None
serverip = None
loadaddr = None
dtb = None
dtb_addr = None
initrd = None
initrd_size_z = 0
initrd_addr = None
initrd_cmdline = False
initrd_uboot = None
uboot_env = None
uboot_early = None
post_reset_ctrl = None
log_prefix = 'boot-%s' %board_name
if not logfile:
    logfile = "%s.txt" %log_prefix
start_time = 0
fastboot = False
fastboot_cmd = "fastboot"
bootargs = None
warnings = 0
boot_meta = {}
custom_boot = False
qemu = None
qemu_args = None
conmux_host = None
locking = True
timings = {}
coreboot = False
bootloader_custom = False

config = configparser.ConfigParser()
config.read(['/etc/pyboot.conf', os.path.expanduser('~/.pyboot'), '.pyboot'])

section = 'DEFAULT'
if config.has_section(board):
    section = board

if debug:
    for item in config.items(section):
        print(item)

# Config file options
if config.has_option(section, 'serverip'):
    serverip = config.get(section, 'serverip')
if config.has_option(section, 'tftproot'):
    tftproot = config.get(section, 'tftproot')
if config.has_option(section, 'image'):
    kimage = config.get(section, 'image')
if config.has_option(section, 'dtb'):
    dtb = config.get(section, 'dtb')
if config.has_option(section, 'initrd'):
    initrd = config.get(section, 'initrd')
if config.has_option(section, 'uboot_env'):
    uboot_env = config.get(section, 'uboot_env')
if config.has_option(section, 'uboot_early'):
    uboot_early = config.get(section, 'uboot_early')
if uimage_addr == 0 and config.has_option(section, 'uimage_addr'):
    uimage_addr = config.get(section, 'uimage_addr')
    convert_uimage = True
if config.has_option(section, 'uimage_addr_default'):
    uimage_addr_default = int(config.get(section, 'uimage_addr_default'), 16)
if config.has_option(section, 'dhcp'):
    dhcp = config.getboolean(section, 'dhcp')
if config.has_option(section, 'fastboot'):
    fastboot = config.get(section, 'fastboot')
if config.has_option(section, 'fastboot_cmd'):
    fastboot_cmd = config.get(section, 'fastboot_cmd')
if config.has_option(section, 'post_reset_ctrl'):
    post_reset_ctrl = config.get(section, 'post_reset_ctrl')
if config.has_option(section, 'bootargs'):
    bootargs = config.get(section, 'bootargs')
if config.has_option(section, 'qemu'):
    qemu = config.get(section, 'qemu')
if qemu:
    if config.has_option(section, "qemu_args"):
        qemu_args = config.get(section, 'qemu_args')
if config.has_option(section, 'conmux_host'):
    conmux_host = config.get(section, 'conmux_host')
if config.has_option(section, 'coreboot'):
    coreboot = config.getboolean(section, 'coreboot')
if config.has_option(section, 'uart_fifo_hack'):
    uart_fifo_hack = int(config.get(section, 'uart_fifo_hack'))

arch = "arm"
if config.has_option(section, "arch"):
    arch = config.get(section, "arch")

if len(args) > 1:
    kimage = args[1]
if len(args) > 2:
    dtb = args[2]
if len(args) > 3:
    initrd = args[3]

boot_meta["version"] = "1.0"
boot_meta["board"] = board_name
if lab_name:
    boot_meta["lab_name"] = lab_name
if mach:
    boot_meta["mach"] = mach

# if build JSON is present, extract some fields for use in the boot JSON
if build_json_file:
    fp = open(build_json_file, "r")
    build_meta = json.load(fp)
    fp.close()
    boot_meta["arch"] = build_meta.get("arch", None)
    boot_meta["kernel"] = build_meta.get("git_describe", None)
    boot_meta["defconfig"] = build_meta.get("defconfig", None)
    job = build_meta.get("job", None)
    if job:
        boot_meta["job"] = job
    git_branch = build_meta.get("git_branch", None)
    if git_branch:
        boot_meta["git_branch"] = git_branch
        # version was updated when git_branch rework was done
        boot_meta["version"] = "1.1"
        
    defconfig_full = build_meta.get("defconfig_full", None)
    if defconfig_full:
        boot_meta["defconfig_full"] = defconfig_full


(kimage, loadaddr) = path_addr_split(kimage)
if not loadaddr:
    if config.has_option(section, 'loadaddr'):
        loadaddr = config.get(section, 'loadaddr')

boot_meta["kernel_image"] = kimage
boot_meta["loadaddr"] = loadaddr

if dtb:
    (dtb, dtb_addr) = path_addr_split(dtb)
    if not dtb_addr:
        if config.has_option(section, 'dtb_append'):
            dtb_append = True
            dtb_addr = ''
        elif config.has_option(section, 'dtb_addr'):
            dtb_addr = config.get(section, 'dtb_addr')

    boot_meta["dtb"] = dtb
    boot_meta["dtb_addr"] = dtb_addr
    boot_meta["dtb_append"] = dtb_append

if not dtb:
    dtb_addr = ''

if initrd:
    (initrd, initrd_addr) = path_addr_split(initrd)
    if initrd:
        initrd_size_z = os.path.getsize(initrd)
        # if no DTB is given (legacy boot), then force initrd_uboot)
        if not dtb:
            initrd_uboot = True
        # but override with config file setting
        if config.has_option(section, 'initrd_uboot'):
            initrd_uboot = config.getboolean(section, 'initrd_uboot')
    if not initrd_addr:
        if config.has_option(section, 'initrd_addr'):
            initrd_addr = config.get(section, 'initrd_addr')
        else:
            initrd_addr = ""

    if initrd and modules:
        initrd = initrd_insert_modules(initrd, modules)
        initrd_size_z = os.path.getsize(initrd)

    boot_meta["initrd"] = initrd
    boot_meta["initrd_addr"] = initrd_addr

if not initrd:
    initrd_addr = ''

# Check endianness of zImage
endian = "little"
if zimage_is_big_endian(kimage):
    endian = "big"

boot_meta["endian"] = endian
boot_meta["fastboot"] = fastboot
if fastboot:
    boot_meta["fastboot_cmd"] = fastboot_cmd
if qemu:
    boot_meta["qemu"] = qemu

if not quiet:
    print("Board:", board)
    print("Kernel:", kimage, loadaddr, "(endian: %s)" %endian)
    if initrd:
        initrd_size = subprocess.check_output("gunzip -l %s" %initrd, shell=True).splitlines()[1].split()[1]
        print("initrd:", initrd, initrd_addr, initrd_size_z, initrd_size)
    if dtb:
        print("DTB:", dtb, end=' ')
        if dtb_append:
            print("(appending to kernel image)")
            dtb_addr = ""
        else:
            print(dtb_addr)

if sys.version_info.major <= 2:
    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) # Unbuffer output
# TODO: http://stackoverflow.com/questions/107705/disable-output-buffering
start_time = time.time()
time_start('total')
time_start('setup')

dtb_orig = dtb
if dtb and initrd_addr and not initrd_uboot:
    dtb = dtb_insert_initrd(dtb, initrd_addr)
if dtb and bootargs:
    if cmdline_append:
        bootargs = bootargs + " " + cmdline_append
    dtb = dtb_insert_cmdline(dtb, bootargs)

if dtb and dtb_append:
    fd, kimage_appended = tempfile.mkstemp(prefix="%s-dtb-" %kimage)
    temp_files.append(kimage_appended)
    subprocess.call('cat %s %s > %s' \
                        %(kimage, dtb, kimage_appended), shell=True)
    os.chmod(kimage_appended, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
    kimage = kimage_appended


if convert_uimage:
    kimage = create_uimage(kimage, uimage_addr)
    boot_meta["uimage"] = True
    boot_meta["uimage_addr"] = uimage_addr

if not qemu:
    if initrd_uboot:
        initrd = initrd_add_uboot_header(initrd)

    tftp_setup()
    kimage = tftp_relpath(kimage)
    if dtb:
        dtb = tftp_relpath(dtb)
    if initrd:
        initrd = tftp_relpath(initrd)

if coreboot:
    its_template = config.get(section, "its_template")
    tftp_host = config.get(section, "tftp_host")
    tftp_dir = config.get(section, "tftp_dir")
    tftp_filename = config.get(section, "tftp_filename")

    #
    # Use template .its file to create real .its file for FIT image.
    # template needs KIMAGE_FILE, DTB_FILE, RAMDISK_FILE which will be
    # replaced with actual filenames.
    #
    # NOTE: when DTB or ramdisk files not used, an empty dummy file
    #       is used in the DTS, *but*, those nodes will be
    #       deleted from the .its below...
    #
    progress("prepare: creating FIT image.")
    its_file = os.path.join(tftpdir, "%s.its" %board)
    fd, dummy = tempfile.mkstemp(dir=tftpdir, prefix="dummy-")
    if dtb:
        dtb_basename = os.path.basename(dtb)
    else:
        dtb_basename = os.path.basename(dummy)
    if initrd:
        initrd_basename = os.path.basename(initrd);
    else:
        initrd_basename = os.path.basename(dummy)

    # search/replace for kernel, dtb and ramdisk filenames
    cmd = "cat %s | sed -e s/KIMAGE_FILE/%s/" % (its_template, os.path.basename(kimage))
    cmd += " -e s/DTB_FILE/%s/" % dtb_basename
    cmd += " -e s/RAMDISK_FILE/%s/" % initrd_basename
    cmd += "> %s" % its_file
    subprocess.call(cmd, shell=True)

    if not os.path.exists(its_file):
        raise Exception("FIT: unable to create FIT .its file")

    #
    # if dtb/initrd are not actually present, add a magic 'delete-node'
    # property so that when .its is compiled, the dtb/initrd node
    # is deleted
    #
    if not dtb:
        fp = open(its_file, "a")
        fp.write("/ { images { /delete-node/ fdt@1; }; };\n")
        fp.close()
    if not initrd:
        fp = open(its_file, "a")
        fp.write("/ { images { /delete-node/ ramdisk@1; }; };\n")
        fp.close()

    # Now, the FIT image can be created.
    fit_file = os.path.splitext(its_file)[0] + ".fit"
    cmd = "mkimage -D \"--include %s -I dts -O dtb -p 500\" -f %s %s > /dev/null" \
          % (tftpdir, its_file, fit_file)
    subprocess.call(cmd, shell=True)

    if not os.path.exists(fit_file):
        raise Exception("FIT: unable to create FIT file")

    #
    # For coreboot/depthcharge netboot, FIT image must be copied to a
    # hard-coded location.
    #
    progress("prepare: coping FIT image to %s:%s" % (tftp_host, tftp_dir))
    cmd = "scp -q %s %s:%s/%s" % (fit_file, tftp_host, tftp_dir, tftp_filename)
    subprocess.call(cmd, shell=True)

    #
    # for coreboot/depthcharge neboot, command-line overrides happen by
    # a special file called 'cmdline' at the hard-coded TFTP location
    #
    if bootargs:
        progress("prepare: copy command-line file to %s:%s" % (tftp_host, tftp_dir))
        cmdline_file = os.path.splitext(its_file)[0] + ".cmdline"
        fp = open(cmdline_file, "w")
        fp.write(bootargs)
        fp.close()
        cmd = "scp -q %s %s:%s/cmdline" % (cmdline_file, tftp_host, tftp_dir)
        subprocess.call(cmd, shell=True)

lock_fp = lock_fd = None
if locking:
    if qemu:
        # only allow a single QEMU instance at a time (HACK for resource constraint host/server)
        lockfile = os.path.join(tempfile.gettempdir(), "pyboot-qemu.lock")
    else:
        lockfile = os.path.join(tempfile.gettempdir(), "pyboot-%s.lock" %board)
    if os.path.exists(lockfile):
        lock_fp = open(lockfile, "w")
    else:
        lock_fp = open(lockfile, "w")
        os.chmod(lockfile, stat.S_IRUSR | stat.S_IWUSR |
                 stat.S_IRGRP | stat.S_IWGRP |
                 stat.S_IROTH | stat.S_IWOTH)

    lock_fd = lock_fp.fileno()

try:
    fcntl.lockf(lock_fd, fcntl.LOCK_EX)
    connect_console()
    time_stop('setup')

    time_start('bootloader')
    is_uboot = False
    if not qemu:
        is_uboot = boot_to_uboot()
        if is_uboot:
            init_uboot_env()

    if fastboot:
        fastboot_image(kimage, dtb, initrd)
    elif bootloader_custom:
        # Just look for prompt, and run commands
        if not config.has_option(section, "bootloader_prompt"):
            raise Exception("bootloader_custom: missing bootloader_prompt.  Giving up.")

        if not config.has_option(section, "bootloader_commands"):
            raise Exception("bootloader_custom: missing bootloader_commands.  Giving up.")

        bootloader_prompt = config.get(section, "bootloader_prompt")
        bootloader_commands = config.get(section, "bootloader_commands")

        c.expect([bootloader_prompt, pexpect.TIMEOUT], timeout=5)

        # pre-process commands to replace filenames
        boot_cmds = []
        for cmd in bootloader_commands.splitlines():
            cmd = cmd.replace("{KERNEL}", kimage)
            if initrd:
                cmd = cmd.replace("{RAMDISK}", initrd)
                cmd = cmd.replace("{RAMDISK_SIZE}", "%d" % initrd_size_z)
            boot_cmds.append(cmd)

        # send commands
        for cmd in boot_cmds[0:-1]:
            command(cmd, bootloader_prompt, timeout=120)

        # the last command is expected to boot the kernel, don't wait for it
        cmd = boot_cmds[-1]
        c.sendline(cmd)

    elif custom_boot:
        # Just run 'boot' using bootcmd from u-boot env
        command('boot')
    elif is_uboot:
        if not dry_run:
            init_net()

        load_image(kimage, loadaddr)
        if initrd:
            load_image(initrd, initrd_addr)
            if initrd_cmdline:
                initrd_addr = "-"
        if dtb and not dtb_append:
            load_image(dtb, dtb_addr)
            if not initrd:
                initrd_addr = '-'  # needed for bootm/bootz if dtb present

        boot_kernel()
    time_stop('bootloader')

    if interact:
        progress('userspace: going interactive.  Use escape char (^]) to exit.')
        c.interact()
        do_report(0)

    quiet_kernel = False
    if cmdline_append and cmdline_append.find("quiet") >= 0:
        quiet_kernel = True
        progress("kernel: starting quiet kernel (no serial output)")

    time_start('kernel')
    if not quiet_kernel:
        wait_for_kernel()
    time_stop('kernel')

    time_start('userspace')
    root_shell()
    if not dry_run:
        userspace_info()

    if check_warnings:
        check_errors_warnings()
    time_stop('userspace')

    if run_tests:
        time_start('tests')
        do_tests()
        time_stop('tests')

    if shutdown:
        progress('userspace: shutting down', log=True)
        c.sendline('halt')
        time.sleep(1)
        poweroff()

    do_report(0)

except Exception as e:
    # ensure we read any remaining input
    if c:
        c.expect([pexpect.EOF, pexpect.TIMEOUT], timeout=1)
    progress('got exception: %s' % e)
    poweroff()
    if c and c.logfile:
        c.logfile.write('# PYBOOT: Exception: %s\n' %e)

    boot_result_description = "%s" %e
    boot_meta["boot_result_description"] = boot_result_description.rstrip()
    # e.args[0] is message, e.args[1] (if present) is result code
    if len(e.args) > 1:
        do_report(1, e.args[1])  # pass result
    else:
        do_report(1)

finally:
    if c and c.logfile:
        c.logfile.close()

    if locking and lock_fd:
        fcntl.lockf(lock_fd, fcntl.LOCK_UN)
        lock_fp.close()

    # remove non-printable chars (and \r) from temp output log, and save to final location
    log_base = os.path.dirname(logfile)
    if log_base and not os.path.exists(log_base):
        os.mkdir(log_base)
    if exp_logfile:
        redir = '>'
        if logfile_append:
            redir = '>>'
        cmd = "tr -dc \'[:print:]\n\' < %s %s %s" %(exp_logfile, redir, logfile)
        subprocess.call(cmd, shell=True)

    tftp_cleanup()
    for f in temp_files:
        if os.path.exists(f):
            if os.path.isdir(f):
                shutil.rmtree(f)
            else:
                os.remove(f)
