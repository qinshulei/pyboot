#!/usr/bin/env python
#
# pyboot: automatically load/boot kernel + DTB + initrd
#
# Automatically load and boot kernel image (and optionally load DTB
# and initrd) on <board> using netboot (DHCP + TFTP).  Images are
# copied to a temporary, TFTP-accessible location (unless already
# under TFTP root dir) so they can be loaded by <board> via TFTP.
#
# Serial console and hardreset/power-down of <board> is handled
# through conmux.  Conmux provides the serial console, and also allows
# special escape that can run arbitrary commands and are useful for
# hardreset and power-off of target board.
#
# Reads config file from /etc/pyboot.conf, $PWD/.pyboot and ~/.pyboot
#
# Author: Kevin Hilman <khilman@kernel.org>
# - with significant early contributions from Olof Johansson <olof@lixom.net>
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
# TODO:
# - generalize bootargs: set by inserting into DTB, not only u-boot env
#   - needs to handle current post-dhcp init (via netargs)
# - instrument kernel backtraces for easy logging/coloring
# - add 'console_host' option in config file for conmux
# - support arch, mach, lab-name, etc. from ~/.pyboot 
#
import os
import sys
import time
import stat
import re
import pexpect
import getopt
import tempfile
import shutil
import subprocess
import ConfigParser
import json
import struct
import fcntl

def usage():
    name = os.path.basename(sys.argv[0])
    print
    print name, "[options] <board> [<kernel>[:addr]] [<dtb>[:addr]] [<initrd>[:addr]"
    print "  -h: this help message"
    print "  -d: enable debug mode"
    print "  -v: display verbose interaction with target"
    print "  -i: after kernel boots, enter interactive mode with serial console"
    print "  -u <addr>: create uImage from zImage with <addr> as load address"
    print "             (useful when u-boot is missing bootz support)"
    print "  -c <cmdline>: append on to kernel commandline"
    print "  -t: run tests defined in config file"
    print

def path_addr_split(path):
    """Split the argument (of the form path[:addr] into (path, addr)"""
    addr = None
    if path == '-':
        return (None, None)
    if path.find(':') != -1:
        (path, addr) = path.split(':')
    if not os.path.exists(path):
        print "ERROR: file", path, "does not exist."
        sys.exit(1)
    return (path, addr)

def progress(str, log=False):
    global start_time, c
    if dry_run:
        return

    t = time.time() - start_time
    min = t / 60
    sec = t % 60
    timestamp = '[%02d:%02d]' %(min, sec)

    if log and c.logfile:
        c.logfile.flush()
        c.logfile.write("\n# PYBOOT: %s\n" %str)

    if verbose:
        # target console output is already verbose enough, don't add to it
        return

    if not quiet:
        print '%s %s' %(timestamp, str)

def create_uimage(zimg, addr_str):
    """ Create uImage from zImage with @addr ad load address. """
    if not os.path.basename(zimg).startswith('z'):
        raise Exception('ERROR: need a zImage to create a uImage: %s' %zimg)

    # Check if 'addr' is hex.  If not, it might be path to System.map,
    # where look for _text symbol to determine load address
    try:
        addr = int(addr_str, 16)
        entry = addr
    except ValueError:
        if os.path.exists(addr_str):
            system_map = addr_str
            virt_text = subprocess.check_output('grep " _text" %s' %system_map, shell=True).split()[0]
            text_offset = '0x' + virt_text.replace('c', '0')
            addr = int(text_offset, 16)
            entry = addr
            if not quiet:
                print "uImage: determined load address (0x%08x) from %s." %(addr, system_map)
        elif addr_str == "xip":
            addr = int(loadaddr, 16)
            entry = addr + 64
            if not quiet:
                print "uImage: XIP mode: Setting uImage load addr to TFTP load addr 0x%08x (and entry point +64b)" %(addr)
        else:
            addr = uimage_addr_default
            entry = addr
            print "WARNING: uImage: Unable to determine load address from %s. Using default 0x%08x" %(addr_str, addr)

    fd, uimg = tempfile.mkstemp(prefix="uImage-")
    temp_files.append(uimg)
    cmd = 'mkimage -A arm -O linux -T kernel -C none -a 0x%x -e 0x%x -n "Linux" -d %s %s > /dev/null' %(addr, entry, zimg, uimg)
    subprocess.call(cmd, shell=True)
    os.chmod(uimg, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
    if not os.path.exists(uimg):
        raise Exception('Unable to create uImage.')
    else:
        progress("Convered zImage to uImage (load address = 0x%08x)" %addr)

    return uimg

def tftp_setup():
    """ Create temp TFTP location. """
    global tftpdir, tftprel

    tftptmp = os.path.join(tftproot, 'tmp')
    if not os.path.exists(tftptmp):
        os.mkdir(tftptmp)
    tftpdir = tempfile.mkdtemp(prefix='%s-' %board, dir=tftptmp)
    os.chmod(tftpdir, stat.S_IRWXU | stat.S_IXGRP | stat.S_IXOTH)
    tftprel = os.path.relpath(tftpdir, tftproot)

def tftp_relpath(path):
    """Copy file into tftproot for access via TFTP and return path.
    If path is already under tftproot, do not copy, just return
    relative path.
    """
    global tftpdir, tftprel

    if path.startswith(tftproot):
        # already in TFTP root, no need to copy, just drop TFTP root prefix
        path = path[len(tftproot)+1:]  
    else:
        shutil.copy(path, tftpdir)
        path = os.path.join(tftprel, os.path.basename(path))
        
    return path

def tftp_cleanup():
    global tftpdir

    if tftpdir:
        shutil.rmtree(tftpdir)
        tftpdir = None

def time_start(key):
    global timings

    if not timings.has_key(key):
        timings[key] = [-1, -1]

    timings[key][0] = time.time()

def time_stop(key):
    timings[key][1] = time.time()

def time_diff(key):
    return timings[key][1] - timings[key][0]

def do_report(retval=0, result=None):
    global start_time, c, boot_meta

    time_stop('total')
    boot_time = time.time() - start_time
    if not result:
        if retval:
            result = 'FAIL'
        else:
            result = 'PASS'
    
    
    report = "# PYBOOT: Time: %.2f seconds.\n" %boot_time
    if warnings:
        report += "# PYBOOT: Warnings: %d\n" %warnings
    report += "# PYBOOT: Result: %s\n" %result
    if not quiet:
        print report

    if c.logfile:
        c.logfile.flush()
        c.logfile.write(report)

    if timings.has_key('kernel'):
        boot_time = round(time_diff('kernel'), 2)
    else:
        boot_time = 0
    boot_meta["boot_time"] = round(boot_time, 2)
    boot_meta["boot_result"] = result
    boot_meta["boot_warnings"] = warnings
    boot_meta["boot_log"] = logfile

    # Create JSON format boot metadata
    json_file, ext = os.path.splitext(logfile)
    json_file += ".json"
    if os.path.exists(json_file):
        boot_json_f = open(json_file, 'r')
        prev_boot_meta = json.load(boot_json_f)
        boot_retries = prev_boot_meta.get("boot_retries", 0)
        boot_json_f.close()
        boot_meta["boot_retries"] = boot_retries + 1

    json_base = os.path.dirname(json_file)
    if json_base and not os.path.exists(json_base):
        os.mkdir(json_base)
    boot_json_f = open(json_file, 'w')
    json.dump(boot_meta, boot_json_f, indent=4, sort_keys=True)
    boot_json_f.close()

    sys.exit(retval)

class dummy_expect:
    """ Dummy expect for debug without using real console. """
    class dummy_match:
        def group(self, i):
            return i
    def __init__(self):
        self.match = self.dummy_match()
        self.logfile = None
    def sendline(self, str):
        print str
    def expect(self, exp=None, timeout=0):
        return 0
    def before(self):
        return 'BEFORE'
        
def connect_console():
    """ Spawn and connect to serial console (via conmux). """
    global c, verbose, exp_logfile
    global kimage, dtb, initrd

    if dry_run:
        c = dummy_expect()
        return

    if qemu:
        qemu_cmd = "%s -nographic %s -kernel %s" %(qemu, qemu_args, kimage)
        if dtb:
            qemu_cmd += " -dtb %s" %dtb
        if initrd:
            qemu_cmd += " -initrd %s" %initrd
        if bootargs:
            qemu_cmd += " -append \"%s\"" %bootargs
        boot_meta["qemu_command"] = qemu_cmd
        c = pexpect.spawn(qemu_cmd, timeout=30)
    else:
        conmux_board = board
        if conmux_host:
            conmux_board = "%s/%s" %(conmux_host, board)
        c = pexpect.spawn("conmux-console %s" %(conmux_board), timeout=30)
    try:
        fd, exp_logfile = tempfile.mkstemp(prefix="conmux-log-")
        temp_files.append(exp_logfile)
        c.logfile = open(exp_logfile, "w")

    except IOError:
        print 'WARNING: Unable to open %s.  Enabling verbose mode.' %logfile
        verbose = True

    #
    # For interactive use (in addition to logging, connect stdout to
    # logfile_read (logfile_read is used so characters are not echo'd
    # twice)
    #
    if verbose:
        c.logfile_read = sys.stdout 

    if qemu:
        # QEMU goes directly to booting the kernel
        progress("qemu: connected using: %s" %qemu_cmd, log=True)
        return;

    i = c.expect(["Connected to", 
                  pexpect.TIMEOUT, pexpect.EOF])
    if i == 0:
        # connected normally
        pass
    else:
        raise Exception('ERROR: Unable to connect to console.  Giving up.', 'OFFLINE')

    c.sendline('')
    progress('console: connected.', log=True)

def sendline(str):
    global c
    c.sendline(str)

def command(str, exp=None, timeout=-1):
    global prompt

    if debug:
        progress('cmd: %s' % str)
    sendline(str)
    i = c.expect([exp or prompt, 
                  pexpect.EOF,
                  pexpect.TIMEOUT], timeout=timeout)
    if i == 0:
        pass
    elif i == 1:
        raise Exception("ERROR: console: unexpectedly disconnected.")
    else:
        raise Exception("ERROR: Timeout waiting for command: %s." %str)

def boot_to_uboot():
    global prompt, post_reset_ctrl
    
    breakin = False
    while not breakin:
        c.sendline('~$hardreset')

        # Send "post_reset_ctrl" character as a control character right after reset
        if post_reset_ctrl:
            time.sleep(4)
            progress("console: send post_reset_ctrl: %s" %post_reset_ctrl)
            for ch in post_reset_ctrl:
                c.sendcontrol(ch)

        # Break into u-boot
        i = c.expect(['stop autoboot:',
                      'BOOT0 is starting',
                      'fastboot: processing commands',
                      'Nokia OMAP Loader',
                      pexpect.TIMEOUT])
        if i == 0:
            breakin = True
        elif i == 1:
            progress('u-boot: HACK: Cubie: old, on-chip bootloader detected.  Resetting again.')
            continue
        elif i == 2:
            progress('u-boot: fastboot mode detected.')
            return False
        elif i == 3:
            progress('u-boot: Nokia OMAP Loader (NOLO) detected.')
            return False
        else:
            raise Exception('ERROR: Could not break into u-boot.', 'OFFLINE')

    c.sendline('\r')
    progress('u-boot: taking control.', log=True)

    # Find u-boot prompt
    try:
        c.expect('[-\w ]*[>#\$]')
    except pexpect.TIMEOUT:
        raise Exception('ERROR: Could not find u-boot prompt.', 'OFFLINE')

    prompt = c.match.group(0)
    if prompt.endswith('$'):
        prompt = prompt[:-1] + "\$"

    return True

def init_uboot_env():
    """ Initialize default u-boot env, including values from config file."""
    global prompt, custom_boot

    # Send this command one char at time
    if uboot_early:
        for ch in uboot_early:
            c.send(ch)
        c.send("\n")

    c.expect(prompt)
    command('version')

    # environment values from config file
    if uboot_env:
        uboot_vars = uboot_env.split('\n')
        uboot_vars = filter(None, uboot_vars) # remove empty items, blank lines...
        for var in uboot_vars:
            (key, val) = var.split('=', 1)
            command('setenv %s %s' %(key, val))

            # If 'bootcmd' is set, assume we shoudl use this instead of the standard
            # netboot method
            if key == "bootcmd":
                custom_boot = True
        
        # if bootargs is set outside of uboot_env, it overrides this one
        if bootargs:
            command('setenv bootargs %s' %bootargs)
        
    command('if test -n ${initenv}; then run initenv; fi')
    command('if test -n ${preboot}; then run preboot; fi')

def init_net():
    global prompt
    retries = 3

    command('setenv autoload no; setenv autoboot no')
    while retries and dhcp:
        sendline("dhcp")
        i = c.expect(["DHCP client bound",
                      "Unknown command",
                      "Retry count exceeded",
                      pexpect.TIMEOUT],
                     timeout = 30)
        if i == 0:
            progress('u-boot: got DHCP address.')
            c.expect(prompt)
            break;
        elif i == 1:
            raise Exception('u-boot: does not support DHCP.  Giving up.')
        else:
            retries = retries - 1
            if retries:
                progress('u-boot: DHCP timeout. Trying again (retries=%d)' \
                             %retries, log=True)
            else:
                raise Exception('u-boot: ERROR: timeout getting DHCP address.')

    if serverip:
        command('setenv serverip %s' %serverip)

    command("if test -n ${netargs}; then run netargs; fi")

def fastboot_image(kernel, dtb, initrd):
    progress('u-boot: entering fastboot mode.', log=True)
    command('printenv bootargs')
    c.sendline(fastboot_cmd)

    # The rest of the fastboot magic here is hidden by conmux
    progress('fastboot: loading %s, %s, %s' % (kernel, dtb, initrd), log=True)
    cmd = "~$fastboot"
    if serverip:
        cmd += " -t %s" %serverip
    cmd += " %s %s %s" % (kernel, dtb, initrd)
    c.sendline(cmd)

def load_image(file, addr):
    global prompt
    retries = 3
    tftp_cmd = 'tftp'
    if serverip:
        file = "%s:%s" %(serverip, file)

    progress('u-boot: TFTP %s to %s' %(file, addr))
    while retries:
        sendline('%s %s %s' %(tftp_cmd, addr, file))
        retries = retries - 1
        i = c.expect(['Bytes transferred', 
                      'TFTP error',
                      'Unknown command',
                      'Retry count exceeded',
                      pexpect.TIMEOUT],
                     timeout=30)
        if (i == 0):
            j = c.expect([prompt, pexpect.TIMEOUT])
            if j != 0:
                raise Exception("u-boot: ERROR: No prompt after TFTP transfer")
            break
        elif (i == 1):
            raise Exception('ERROR: TFTP error.')
        elif (i == 2):
            if tftp_cmd == "tftp":
                progress("u-boot: tftp command not present, trying tftpboot")
                tftp_cmd = "tftpboot"
                c.expect(prompt)
            else:
                raise Exception("ERROR: u-boot doesn't support TFTP")
        else:
            if retries:
                progress('u-boot: timeout loading %s, Trying again.' %file, log=True)
                c.send('\003')  # Ctrl-C: abort current tftp
                j = c.expect([prompt, pexpect.TIMEOUT])
                if j != 0:
                    raise Exception("u-boot: ERROR: No prompt after interrupting TFTP.")
            else:
                raise Exception('ERROR: Timeout loading %s.  Giving up.' %file)

def boot_kernel():
    global prompt, initrd_addr

    boot_cmd='bootm'
    if os.path.basename(kimage)[0] == 'z':
        boot_cmd='bootz'

    if cmdline_append:
        command('setenv bootargs ${bootargs} %s' %cmdline_append)

    command('printenv bootargs')

    # Boot the kernel
    sendline('%s %s %s %s' %(boot_cmd, loadaddr, initrd_addr, dtb_addr))
    progress("u-boot: jumping to kernel image", log=True)

    # U-boot should tell us quickly that it's starting the kernel
    i = c.expect(['Starting kernel',
                  'Unknown command',
                  'Wrong Image Type for bootm',
                  'Bad Linux ARM zImage magic',
                  pexpect.TIMEOUT],
                 timeout = 10)
    if i == 0:
        # Kernel started normally
        pass
    elif i == 1:
        raise Exception('u-boot: ERROR: does not support command: %s' %boot_cmd)
    elif i == 2:
        raise Exception('u-boot: ERROR: missing (or overwritten) uImage header')
    elif i == 3:
        raise Exception('u-boot: ERROR: Bad Linux ARM zImage magic.' )
    elif i == 4:
        raise Exception('u-boot: ERROR: Kernel did not start.')

    progress('u-boot: started kernel.')

def wait_for_kernel():
    global warnings

    i = c.expect(['Booting Linux',
                  'Linux version',
                  pexpect.TIMEOUT, pexpect.EOF], timeout = 30)
    if i == 0 or i == 1:
        # normal booting
        pass
    if i == 2:
        raise Exception('kernel: ERROR: did not start booting.')
    if i == 3:
        raise Exception('console: error connecting with console/qemu.', 'OFFLINE')

    time_start('kernel')
    progress('kernel: started booting.')

    # Look for end of kernel boot, or various failures
    done = False
    while not done:
        pl = ['Freeing unused kernel memory',
              'Freeing init memory',
              'Unable to handle kernel (.*)\r\n',
              'Kernel panic',
              'VFS: Unable to mount root fs',
              '-+\[ cut here \]-+\s+(.*\s+-+\[ end trace (\w*) \]-+)',
              '(Unhandled fault.*)\r\n',
              pexpect.TIMEOUT]
        i = c.expect(pl, timeout=90)
        if i == 0 or i == 1:  
            # Kernel booted normally
            done = True
        elif i == 2:
            msg = c.match.group(0)
            raise Exception("kernel: %s" %msg)
        elif i == 5:
            warnings += 1
            progress("kernel: boot warning:")
            if not quiet:
                print c.match.group(1)
            continue
        elif i == 6:
            warnings += 1
            msg = c.match.group(0)
            progress("kernel: %s" %msg, log=True)
            continue
        elif i == 7:
            raise Exception("kernel: ERROR: Timeout waiting for kernel to finish booting.")
        else:
            raise Exception('kernel: ERROR: failed to boot: %s' %pl[i])

    time_stop('kernel')
    progress('kernel: finished booting, starting userspace.', log=True)

def root_shell():
    """ Wait for linux root shell. """
    global prompt, warnings

    # Wait for linux root shell
    prompt = "# "
    pl = [prompt,
          "press Enter to activate",  # busybox
          pexpect.TIMEOUT,
          "Kernel panic",
          "(Unhandled fault.*)\r\n",
    ]
    done = False
    while not done:
        i = c.expect(pl, timeout=120)
        if i == 0:
            done = True
        elif i == 1:
            command('\n')
            done = True
        elif i == 2:
            raise Exception('userspace: ERROR: Timeout waiting for root shell')
        elif i == 4:
            warnings += 1
            msg = c.match.group(0)
            progress('kernel: %s' %msg, log=True)
        else:
            raise Exception('userspace: failed to find root shell: %s' %pl[i])
    
    progress("userspace: at root shell", log=True)

def userspace_info():
    global prompt, kernelversion

    command('cat /proc/cmdline')
    progress('userspace: Kernel command line: %s' %c.before.split('\n')[-2])

    command('uname -r')

    kernelversion = c.before.split('\n')[-2]
    progress('userspace: found kernel version: %s' % kernelversion)

    command('cat /proc/cpuinfo')
    for line in c.before.split('\n'):
        match = re.match('Hardware\s+:\s+(.+)\r', line)
        if match:
            progress('userspace: Hardware: %s' %match.group(1))

    if modules:
        command('lsmod')

def check_errors_warnings():
    # FIXME: these commands are sometimes causing problems when interacting with late output
    #        kernel messgages (like USB devices appearing on mirabox.)  To prevent
    #        strange interactions, turn off kernel message output to console.
    command('dmesg -n 1')  # prevent kernel message output from interfering with this
    # "dmesg -l" requires "real" dmesg, not busybox dmesg
    command('DMESG=$(readlink -f /bin/dmesg)')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l warn | awk \'{ print "[WARN] " $0 }\'')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l err | awk \'{ print "[ERR] " $0 }\'')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l alert | awk \'{ print "[ERR] " $0 }\'')
    # or, on busybox, just check for kern.err, kern.warn in /var/log/messages
    command('[[ -e /var/log/messages ]] && grep kern.warn /var/log/messages | awk \'{ print "[WARN] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep kern.err /var/log/messages | awk \'{ print "[ERR] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep kern.alert /var/log/messages | awk \'{ print "[ERR] " $0 }\'')
    command('sleep 0.2')

def run_test(test, cmd):
    timeout = 1200

    progress('test: %s: %s' %(test, cmd), log=True)
    command(cmd, timeout=timeout)
    command('echo $?')
    retval = int(c.before.split('\n')[-2])
    if retval == 0:
        pass_fail = 'PASS'
    else:
        pass_fail = 'FAIL'
        
    progress("test: %s: returned %d: %s"  %(test, retval, pass_fail), log=True)
    
def do_tests():
    # Board-specific tests
    for o in config.options(section):
        if o.startswith('test_'):
            test = o[5:] # drop 'test_' prefix from test name
            cmd = config.get(section, o)
            run_test(test, cmd)

    # Tests defined in [test] section
    if not config.has_section('test'):
        return

    tests = config.options('test')
    for test in tests:
        # ignore options from DEFAULTS section
        if config.defaults().has_key(test):
            continue
        cmd = config.get('test', test)
        run_test(test, cmd)

def poweroff():
    global c
    c.sendline('~$off')

def dtb_insert_initrd(dtb, initrd_addr):
    """ Insert initrd start/end addresses into DTB.
    
    NOTE: we could use fdtput for this but the original DTB needs to have
    enough padding in it for the new commandline, which is not guaranteed.
    """
    global initrd_cmdline

    # de-compile DTB into temp DTS
    fd, tmp_dts = tempfile.mkstemp(suffix=".dts")
    temp_files.append(tmp_dts)
    os.close(fd)
    cmd = "dtc -q -I dtb -O dts -o %s %s > /dev/null 2>&1" %(tmp_dts, dtb)
    subprocess.call(cmd, shell=True)

    initrd_start = int(initrd_addr, 16)
    initrd_end = initrd_start + initrd_size
    chosen_frag = "/ { chosen { linux,initrd-start = <0x%08x>; linux,initrd-end = <0x%08x>; }; };\n" %(initrd_start, initrd_end)
    fp = open(tmp_dts, 'a')
    fp.write(chosen_frag)
    fp.close()
    initrd_cmdline = True

    # Re-compile DTS into new DTB
    fd, dtb_modified = tempfile.mkstemp(suffix=".dtb")
    temp_files.append(dtb_modified)
    os.close(fd)
    cmd = "dtc -I dts -O dtb -o %s %s > /dev/null 2>&1" %(dtb_modified, tmp_dts)
    subprocess.call(cmd, shell=True)
    os.unlink(tmp_dts)
    os.chmod(dtb_modified, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    if not quiet:
        print "DTB: modified for initrd: %s" %dtb_modified
    return dtb_modified

def dtb_insert_cmdline(dtb, cmdline):
    global bootargs

    # de-compile DTB into temp DTS
    fd, tmp_dts = tempfile.mkstemp(suffix=".dts")
    temp_files.append(tmp_dts)
    os.close(fd)
    cmd = "dtc -q -I dtb -O dts -o %s %s > /dev/null 2>&1" %(tmp_dts, dtb)
    subprocess.call(cmd, shell=True)

    chosen_frag = '/ { chosen { bootargs = "%s"; }; };\n' %bootargs
    fp = open(tmp_dts, 'a')
    fp.write(chosen_frag)
    fp.close()

    # Re-compile DTS into new DTB
    fd, dtb_modified = tempfile.mkstemp(suffix=".dtb")
    temp_files.append(dtb_modified)
    os.close(fd)
    cmd = "dtc -I dts -O dtb -o %s %s > /dev/null 2>&1" %(dtb_modified, tmp_dts)
    subprocess.call(cmd, shell=True)
    os.unlink(tmp_dts)
    os.chmod(dtb_modified, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    if not quiet:
        print "DTB: modified with bootargs: %s.\n" %bootargs,
    return dtb_modified


def initrd_add_uboot_header(initrd):
    """Add u-boot initrd header so it can be booted using u-boot bootm/bootz."""
    basename = os.path.basename(initrd)
    fd, initrd_uboot_tmp = tempfile.mkstemp(prefix=basename, suffix=".uboot")
    temp_files.append(initrd_uboot_tmp)
    os.close(fd) 
    cmd = "mkimage -A arm -O linux -T ramdisk -C none -a 0 -e 0 -n %s -d %s %s > /dev/null" %(basename, initrd, initrd_uboot_tmp)
    subprocess.call(cmd, shell=True)
    if os.path.exists(initrd_uboot_tmp):
        if not quiet:
            print("initrd: Added u-boot header.  Modified initrd: %s" %initrd_uboot_tmp)
        os.chmod(initrd_uboot_tmp, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
        initrd_size = os.path.getsize(initrd_uboot_tmp)
        return initrd_uboot_tmp
    else:
        raise Exception("Unable to add u-boot header to initrd %s" %initrd)

def initrd_insert_modules(initrd, modules):
    initrd_tmpdir = tempfile.mkdtemp(prefix="initrd-")
    temp_files.append(initrd_tmpdir)
    fd, initrd_new = tempfile.mkstemp(prefix="initrd-", suffix=".cpio")

    # extract ramdisk into tmp dir
    if initrd.endswith(".cpio"):
        cat_cmd = "cat"
    elif initrd.endswith(".cpio.gz"):
        cat_cmd = "zcat"
    else:
        return None

    cmd = "cd %s && %s %s | fakeroot cpio --extract --quiet" %(initrd_tmpdir, cat_cmd, initrd)
    subprocess.call(cmd, shell=True)

    # unpack modules into tmp dir
    cmd = "tar -C %s -xaf %s" %(initrd_tmpdir, modules)
    subprocess.call(cmd, shell=True)

    # (re)create ramdisk
    cmd = "cd %s && find . | fakeroot cpio --create --quiet --format='newc' > %s" %(initrd_tmpdir, initrd_new)
    subprocess.call(cmd, shell=True)
    subprocess.call("gzip %s" %initrd_new, shell=True)
    initrd_new += ".gz"
    os.chmod(initrd_new, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    if not debug:
        print "initrd: Inserted modules (%s) into new ramdisk: %s" %(modules, initrd_new)
    temp_files.append(initrd_new)

    return initrd_new

def zimage_is_big_endian(kimage):
    """Check zImage big-endian magic number"""
    magic_offset = 0x30
    setend_be = 0xf1010200
    setend_be_thumb = 0xb658

    fp = open(kimage, "r")
    fp.seek(magic_offset)
    val = struct.unpack("=L", fp.read(4))[0]
    fp.seek(magic_offset)
    val16 = struct.unpack("<H", fp.read(2))[0]
    fp.close()
    if (val == 0x01020304) or (val == setend_be):
        return True
    return False

def zimage_hack_endian(kimage):
    zimage_magic_offset = 0x24
    zimage_magic = 0x016f2818
    magic_hack = struct.pack("<L", zimage_magic)  # ensure LE

    fd, zimage_hack = tempfile.mkstemp(prefix="zImage-hack-")
    temp_files.append(zimage_hack)
    os.close(fd)
    shutil.copyfile(kimage, zimage_hack)

    fp = open(zimage_hack, 'r+')
    fp.seek(zimage_magic_offset)
    fp.write(magic_hack)
    fp.close()
    print "zImage: HACK: forcing little-endian magic number in %s" %zimage_hack
    return zimage_hack

verbose = False
interact = False
uimage_addr = 0
uimage_addr_default = 0x00008000
convert_uimage = False
shutdown = False  # shutdown/halt and poweroff board when done
cmdline_append = ""
debug = False
dry_run = False
quiet = False
prompt = ''
logfile = None
exp_logfile = None
run_tests = False
check_warnings = False
dhcp = True
dtb_append = False
modules = None
build_json_file = None
temp_files = []
lab_name = None
board_name = None
mach = None

try:
    opts, args = getopt.getopt(sys.argv[1:], "ab:c:dhil:L:m:M:n:qstu:vwy")

except getopt.GetoptError as err:
    print str(err) # will print something like "option -a not recognized"
    sys.exit(2)
for o, a in opts:
    if o == "-a":
        dtb_append = True
    if o == "-b":
        build_json_file = a
    elif o == "-c":
        cmdline_append = a
    elif o == "-d":
        debug = True
    elif o == "-y":
        dry_run = True
    elif o == "-h":
        usage()
        sys.exit(0)
    elif o == "-i":
        interact = True
    elif o == "-k":
        locking = False
    elif o == "-l":
        logfile = a
    elif o == "-L":
        lab_name = a
    elif o == "-m":
        modules = a
    elif o == "-M":
        mach = a
    elif o == "-n":
        board_name = a
    elif o == "-s":
        shutdown = True
    elif o == "-q":
        quiet = True
    elif o == "-t":
        run_tests = True
    elif o == "-u":
        convert_uimage = True
        uimage_addr = a
    elif o == "-v":
        verbose = True
    elif o == "-w":
        check_warnings = True
    else:
        assert False, "unhandled option %s" %o
 
if len(args) < 1:
    usage()
    sys.exit(1)

board = args[0]  # conmux console name
if not board_name:
    board_name = board # used for boot JSON board name
tftproot = '/tftpboot'
tftpdir = None
serverip = None
loadaddr = None
dtb = None
dtb_addr = None
initrd = None
initrd_size = 0
initrd_addr = None
initrd_cmdline = False
initrd_uboot = None
uboot_env = None
uboot_early = None
post_reset_ctrl = None
log_prefix = 'boot-%s' %board_name
if not logfile:
    logfile = "%s.txt" %log_prefix
start_time = 0
boot_time = 0
fastboot = False
fastboot_cmd = "fastboot"
bootargs = None
warnings = 0
boot_meta = {}
custom_boot = False
qemu = None
qemu_args = None
conmux_host = None
locking = True
timings = {}

config = ConfigParser.ConfigParser()
config.read(['/etc/pyboot.conf', os.path.expanduser('~/.pyboot'), '.pyboot'])

section = 'DEFAULT'
if config.has_section(board):
    section = board

if debug:
    for item in config.items(section):
        print item

# Config file options
if config.has_option(section, 'serverip'):
    serverip = config.get(section, 'serverip')
if config.has_option(section, 'tftproot'):
    tftproot = config.get(section, 'tftproot')
if config.has_option(section, 'image'):
    kimage = config.get(section, 'image')
if config.has_option(section, 'dtb'):
    dtb = config.get(section, 'dtb')
if config.has_option(section, 'initrd'):
    initrd = config.get(section, 'initrd')
if config.has_option(section, 'uboot_env'):
    uboot_env = config.get(section, 'uboot_env')
if config.has_option(section, 'uboot_early'):
    uboot_early = config.get(section, 'uboot_early')
if uimage_addr == 0 and config.has_option(section, 'uimage_addr'):
    uimage_addr = config.get(section, 'uimage_addr')
    convert_uimage = True
if config.has_option(section, 'uimage_addr_default'):
    uimage_addr_default = int(config.get(section, 'uimage_addr_default'), 16)
if config.has_option(section, 'dhcp'):
    dhcp = config.getboolean(section, 'dhcp')
if config.has_option(section, 'fastboot'):
    fastboot = config.get(section, 'fastboot')
if config.has_option(section, 'fastboot_cmd'):
    fastboot_cmd = config.get(section, 'fastboot_cmd')
if config.has_option(section, 'post_reset_ctrl'):
    post_reset_ctrl = config.get(section, 'post_reset_ctrl')
if config.has_option(section, 'bootargs'):
    bootargs = config.get(section, 'bootargs')
if config.has_option(section, 'qemu'):
    qemu = config.get(section, 'qemu')
if qemu:
    if config.has_option(section, "qemu_args"):
        qemu_args = config.get(section, 'qemu_args')
if config.has_option(section, 'conmux_host'):
    conmux_host = config.get(section, 'conmux_host')

if len(args) > 1:
    kimage = args[1]
if len(args) > 2:
    dtb = args[2]
if len(args) > 3:
    initrd = args[3]

boot_meta["version"] = "1.0"
boot_meta["board"] = board_name
if lab_name:
    boot_meta["lab_name"] = lab_name
if mach:
    boot_meta["mach"] = mach

# if build JSON is present, extract some fields for use in the boot JSON
if build_json_file:
    fp = open(build_json_file, "r")
    build_meta = json.load(fp)
    fp.close()
    boot_meta["arch"] = build_meta.get("arch", None)
    boot_meta["kernel"] = build_meta.get("git_describe", None)
    boot_meta["defconfig"] = build_meta.get("defconfig", None)
    job = build_meta.get("job", None)
    if job:
        boot_meta["job"] = job

    defconfig_full = build_meta.get("defconfig_full", None)
    if defconfig_full:
        boot_meta["defconfig_full"] = defconfig_full


(kimage, loadaddr) = path_addr_split(kimage)
if not loadaddr:
    if config.has_option(section, 'loadaddr'):
        loadaddr = config.get(section, 'loadaddr')

boot_meta["kernel_image"] = kimage
boot_meta["loadaddr"] = loadaddr
    
if dtb:
    (dtb, dtb_addr) = path_addr_split(dtb)
    if not dtb_addr:
        if config.has_option(section, 'dtb_append'):
            dtb_append = True
            dtb_addr = ''
        elif config.has_option(section, 'dtb_addr'):
            dtb_addr = config.get(section, 'dtb_addr')

    boot_meta["dtb"] = dtb
    boot_meta["dtb_addr"] = dtb_addr
    boot_meta["dtb_append"] = dtb_append

if not dtb:
    dtb_addr = ''

if initrd:
    (initrd, initrd_addr) = path_addr_split(initrd)
    if initrd:
        initrd_size = os.path.getsize(initrd)
        if config.has_option(section, 'initrd_uboot'):
            initrd_uboot = config.getboolean(section, 'initrd_uboot')
    if not initrd_addr:
        if config.has_option(section, 'initrd_addr'):
            initrd_addr = config.get(section, 'initrd_addr')
        else:
            initrd_addr = ""

    if initrd and modules:
        initrd = initrd_insert_modules(initrd, modules)
        initrd_size = os.path.getsize(initrd)

    boot_meta["initrd"] = initrd
    boot_meta["initrd_addr"] = initrd_addr

if not initrd:
    initrd_addr = ''

# Check endianness of zImage
endian = "little"
if zimage_is_big_endian(kimage):
    endian = "big"

boot_meta["endian"] = endian
boot_meta["fastboot"] = fastboot
if fastboot:
    boot_meta["fastboot_cmd"] = fastboot_cmd
if qemu:
    boot_meta["qemu"] = qemu

if not quiet:
    print "Board:", board
    print "Kernel:", kimage, loadaddr, "(endian: %s)" %endian
    if initrd:
        print "initrd:", initrd, initrd_addr, initrd_size
    if dtb:
        print "DTB:", dtb, 
        if dtb_append:
            print "(appending to kernel image)"
            dtb_addr = ""
        else:
            print dtb_addr

sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) # Unbuffer output
start_time = time.time()
time_start('total')

if dtb and initrd_addr and not initrd_uboot:
    dtb = dtb_insert_initrd(dtb, initrd_addr)
if dtb and bootargs:
    if cmdline_append:
        bootargs = bootargs + " " + cmdline_append
    dtb = dtb_insert_cmdline(dtb, bootargs)

if dtb and dtb_append:
    fd, kimage_appended = tempfile.mkstemp(prefix="zImage-dtb-")
    temp_files.append(kimage_appended)
    subprocess.call('cat %s %s > %s' \
                        %(kimage, dtb, kimage_appended), shell=True)
    os.chmod(kimage_appended, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
    kimage = kimage_appended


if convert_uimage:
    kimage = create_uimage(kimage, uimage_addr)
    boot_meta["uimage"] = True
    boot_meta["uimage_addr"] = uimage_addr

if not qemu:
    if (initrd and not dtb) or initrd_uboot:
        initrd = initrd_add_uboot_header(initrd)

    tftp_setup()
    kimage = tftp_relpath(kimage)
    if dtb:
        dtb = tftp_relpath(dtb)
    if initrd:
        initrd = tftp_relpath(initrd)

lock_fp = lock_fd = None
if locking:
    lockfile = os.path.join(tempfile.gettempdir(), "pyboot-%s.lock" %board)
    lock_fp = open(lockfile, "w")
    lock_fd = lock_fp.fileno()
    fcntl.lockf(lock_fd, fcntl.LOCK_EX)

try:
    connect_console()
    if not qemu:
        if boot_to_uboot():
            init_uboot_env()

    if fastboot:
        fastboot_image(kimage, dtb, initrd)
    elif custom_boot:
        # Just run 'boot' using bootcmd from u-boot env
        command('boot')
    elif qemu:
        pass
    else:
        if not dry_run:
            init_net()

        load_image(kimage, loadaddr)
        if initrd:
            load_image(initrd, initrd_addr)
            if initrd_cmdline:
                initrd_addr = "-"
        if dtb and not dtb_append:
            load_image(dtb, dtb_addr)
            if not initrd:
                initrd_addr = '-'  # needed for bootm/bootz if dtb present

        boot_kernel()

    if interact:
        progress('userspace: going interactive.  Use escape char (^]) to exit.')
        c.interact()
        do_report(0)
    else:
        wait_for_kernel()

    root_shell()
    if not dry_run:
        userspace_info()

    if check_warnings:
        check_errors_warnings()

    if run_tests:
        do_tests()

    if shutdown:
        progress('userspace: shutting down', log=True)
        c.sendline('halt')
        time.sleep(1)
        poweroff()

    do_report(0)

except Exception as e:
    # ensure we read any remaining input
    c.expect([pexpect.EOF, pexpect.TIMEOUT], timeout=1)
    progress('got exception: %s' % e)
    poweroff()
    if c.logfile:
        c.logfile.write('# PYBOOT: Exception: %s\n' %e)

    boot_result_description = "%s" %e
    boot_meta["boot_result_description"] = boot_result_description.rstrip()
    # e.args[0] is message, e.args[1] (if present) is result code
    if len(e.args) > 1:
        do_report(1, e.args[1])  # pass result 
    else:
        do_report(1)

finally:
    if c.logfile:
        c.logfile.close()

    if locking and lock_fd:
        fcntl.lockf(lock_fd, fcntl.LOCK_UN)
        lock_fp.close()

    # remove non-printable chars (and \r) from temp output log, and save to final location
    log_base = os.path.dirname(logfile)
    if log_base and not os.path.exists(log_base):
        os.mkdir(log_base)
    cmd = "tr -dc \'[:print:]\n\' < %s > %s" %(exp_logfile, logfile)
    subprocess.call(cmd, shell=True)

    tftp_cleanup()
    for f in temp_files:
        if os.path.exists(f):
            if os.path.isdir(f):
                shutil.rmtree(f)
            else:
                os.remove(f)
